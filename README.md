"# designPattern" 
常用设计模式练习代码

Observer:观察者模式

定义：观察者模式定义了对象之间一种一对多的关系，当主体对象的状态信息发生变化时，所有依赖于它的观察者都会得到通知并且自动更新状态。

优点：动态联动，观察者与主体的松耦合。

推模型：推模型推部分数据给观察者，有局限性。

拉模型：拉模型直接将目标对象传递给观察者，观察者根据需要取出数据。

类图：
![Alt text](https://github.com/eddiepengdenvren/designPattern/raw/master/images/Observer.png)





COR:Chain of Responsibility:责任链模式

定义：作为请求接受者的多个对象通过对其后继的引用连接起来形成一条链，客户端的请求在这条链上传递，直到链上的某一个接收者处理这个请求，每个接收者都可以选择自行处理请求或是向后继传递请求。

优点：责任链模式提供给客户端的只有一个接口，而不是某个具体的类，体现了客户端与业务逻辑的松耦合，客户端并不知道自己的请求被哪一个接收者处理，客户端只关心自己的请求能够被处理。责任链模式体现了面向对象设计原则中的依赖于抽象，而不依赖于具体，对新增开放，对修改关闭，使客户端和业务逻辑充分解耦。

缺点：
1.性能：
  接收用户请求时需要遍历责任链直到某个handler处理了这个请求或者遍历完整条责任链才算处理完这个请求。相比处理请求，可能责任链的传递花费的时间更多，会造成性能的损耗。

2.内存：
  责任链需要初始化多个对象，处理客户端请求时只会用到一个handler，对于内存来说是一种消耗。
  
3.实际应用：
  过滤器：有一点点区别，过滤器中可能有多个处理器会处理请求。而责任链模式中只会有一个handler处理请求。

类图：
![Alt text](https://github.com/eddiepengdenvren/designPattern/raw/master/images/COR.png)

单例模式:Singleton  保证只会存在一个实例，需要使用双重检测机制判断实例是否为空，同时要使用volatile保证构造单例时的指令重排序导致的返回为初始化的单例对象

模板方法模式:

模板方法实现要素：准备一个抽象模板父类，父类中一部分逻辑以具体方法实现，然后声明一些抽象方法交给子类定制个性化实现，父类可以声明一些钩子函数，给子类更大的灵活性，最后父类将所有的具体和抽象方法汇总成一个不可改变的(final)模板方法。

模板方法的适用场景：

1.算法或操作有相似的逻辑

2.旧项目重构时把相同的代码抽取到父类中

3.新项目分析业务功能时，将相同的算法设计为模板算法

优点:

1.封装性好，核心算法封装到抽象父类中，对外只提供一个公用的不可更改的模板方法

2.复用性好，核心算法集成了多种功能，客户端可以轻松实现复用

3.屏蔽细节，父类已经实现部分模板功能，无需子类实现，对外不会暴露细节

4.便于维护，开发成本降低，以后维护的成本降低，维护只需要修改抽象父类逻辑

缺点：
JAVA支持单继承，对于旧系统中多数类已经处于继承层次中，无法再次实现一个抽象的模板父类

类图：
![Alt text](https://github.com/eddiepengdenvren/designPattern/raw/master/images/modelMethod.jpg)

适配器模式:

适配器模式将一个类的接口转换成用户期望的另外一个接口，使得原本由于接口不兼容而不能一起工作的类在一起工作。

作用：

1.复用了当前存在的类，解决了现存类和复用环境要求不一致的问题。

2.将目标类和适配者类解耦，通过引入一个适配器类重用了适配者类，而无需修改原有代码，遵循了开闭原则。

类图：
![Alt text](https://github.com/eddiepengdenvren/designPattern/raw/master/images/adapter.png)


